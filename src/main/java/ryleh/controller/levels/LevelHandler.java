
package ryleh.controller.levels;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import ryleh.common.P2d;
import ryleh.common.Pair;
import ryleh.common.Rectangle2d;
import ryleh.controller.Entity;
import ryleh.core.GameState;
import ryleh.core.factories.BasicFactory;
import ryleh.model.Type;
import ryleh.model.World;

//to determine where to spawn the entities generated by Level Designer
public class LevelHandler {

    /*PROBLEMI PRINCIPALI
     * - come spawnare dentro il gamestate?
     * - come gestire la view?
     * - come gestire l'input?
     * - aggiungere item e porte alla factory
     */
        public static final double DRUNK_SPAWN_DISTANCE=2;
        public static final double LURKER_SPAWN_DISTANCE=3;
        public static final double SHOOTER_SPAWN_DISTANCE=4;
        public static final double SPINNER_SPAWN_DISTANCE=3;

        //map entitty values
        public static final double ROCK_SPAWN_DISTANCE=2;
        public static final double FIRE_SPAWN_DISTANCE=1;
        public static final double ITEM_SPAWN_DISTANCE=1;
	
	private int entityCounter;
	//the number of spawn points is determined
	private Map<Pair<Integer, Integer>, Entity> spawnPoints;
	private static int COLUMNS = 9;
	private static int ROWS = 5;
	private int nEnemies;
	private boolean hasItem;
	private LevelDesigner designer;
	private World world;
	private GameState gameState;
	private int nRooms;
	private P2d boundsCoord;
	private double boundsWidth;
	private double boundsHeight;
	
	public Pair<Integer, Integer> playerSpawn;
	
	public LevelHandler(final GameState gameState) {
	    this.gameState = gameState;
	    this.world = gameState.getWorld();
	    this.designer = new LevelDesigner();
	    spawnPoints = new HashMap<>();
	    boundsCoord = ((Rectangle2d) world.getBounds()).upperLeft;
	    boundsWidth = world.getWidthBound();
	    boundsHeight = world.getHeightBound();
	    playerSpawn = new Pair<>(Math.round(COLUMNS / 2), ROWS - 1);
	    nEnemies = 0;
	    hasItem = false;
	    entityCounter = 0;
	    nRooms = 0;
	}
	

	public void generateNewLevel() {
		spawnPoints.clear();
		nEnemies = 1;
		designer.clearLevel();
		hasItem = false;
		nRooms++;
		final List<Type> entityList = designer.generateLevelEntities();
		if (entityList.contains(Type.ENEMY_DRUNKSPINNER)) {
			spawnPoints.put(new Pair<>(4, 0), null);
		}
		for (final Type elem : entityList) {
			switch (elem) {
			case ENEMY_DRUNK:
				nEnemies++;
				//addEntity("drunk", DRUNK_SPAWN_DISTANCE);
				break;
			case ENEMY_LURKER:
				nEnemies++;
				//addEntity("lurker", LURKER_SPAWN_DISTANCE);
				break;
			case ENEMY_SHOOTER:
				nEnemies++;
				//addEntity("shooter", SHOOTER_SPAWN_DISTANCE);
				break;
			case ENEMY_SPINNER:
				nEnemies++;
				//addEntity("spinner", SPINNER_SPAWN_DISTANCE);
				break;
			case ENEMY_DRUNKSPINNER:
				nEnemies++;
				//addEntity("drunkSpinner", new Pair<>(4, 0));
				break;
			case ROCK:
				//addEntity("rock", ROCK_SPAWN_DISTANCE);
				break;	
			case FIRE:
				//addEntity("fire", FIRE_SPAWN_DISTANCE);
				break;	
			case ITEM: //Spawn mechanics when all enemies are defeated 
				//addEntity("item", Config.ITEM_SPAWN_DISTANCE);
				hasItem = true;
				break;
			default:
				//addEntity("rock", ROCK_SPAWN_DISTANCE);
				break;
			}
		}
		//currentLevel = new Level(COLUMNS, ROWS, spawnPoints.values().stream().collect(Collectors.toList())); //TODO
		//currentLevel.getEntities().add(FXGL.getGameWorld().create("background", new SpawnData(0, 0)));
		//FXGL.getGameWorld().setLevel(currentLevel);
		//final Entity player = control.getPlayer();
		//player.setZ(1000);
		//if (FXGL.geti("rooms") >= 2) {
		//	player.getComponent(PhysicsComponent.class)
		//			.overwritePosition(LevelHandler.getPosition(LevelHandler.playerSpawn)
		//			.subtract(new Point2D(Config.scaleFixer(), Config.scaleFixer())));
		//}
		decreaseEnemies();
	}
	
	//determine ? type in the map
	public P2d getPosition(final Pair<Integer, Integer> position) {
		return new P2d(((boundsWidth / COLUMNS)) * position.getX() + boundsCoord.x,
				((boundsHeight / ROWS)) * position.getY() + boundsCoord.y);
	}
	/*
	 * @returns a random position inside the map of SpawnPoints
	 */
	public Pair<Integer, Integer> getRandomSpawnPoint() {
		//TODO 
		final Random generator = new Random();
		Pair<Integer, Integer> random;
		do {
			 random = new Pair<>(generator.nextInt(COLUMNS), generator.nextInt(ROWS));
		} while (spawnPoints.containsKey(random) && entityCounter < ROWS * COLUMNS && !random.equals(playerSpawn));
		entityCounter++;
		return random;
	}
	public Pair<Integer, Integer> getRandomSpawnPoint(final double minDistance) {
		//TODO 
		final Random generator = new Random();
		Pair<Integer, Integer> random;
		do {
			 random = new Pair<>(generator.nextInt(COLUMNS), generator.nextInt(ROWS));
		} while (spawnPoints.containsKey(random) && entityCounter < ROWS * COLUMNS && !random.equals(playerSpawn)
				 && getDistanceFromSpawn(random)<minDistance);
		entityCounter++;
		return random;
	}
	private double getDistanceFromSpawn(final Pair<Integer, Integer> point) {
		return Math.sqrt(Math.pow(point.getX() - playerSpawn.getX(), 2) 
		        + Math.pow(point.getY() - playerSpawn.getY(), 2));
	}
	/*private void addEntity(final String type, final double distance) {
		Pair<Integer, Integer> temp;
		temp = getRandomSpawnPoint(distance);
		spawnPoints.put(temp, FXGL.getGameWorld().create(type, new SpawnData(getPosition(temp))));
	}
	
	private void addEntity(final String type, final Pair<Integer, Integer> point) {
		spawnPoints.put(point, FXGL.getGameWorld().create("drunkSpinner", new SpawnData(getPosition(point))));
	}
*/
	public Pair<Integer, Integer> getPlayerSpawn() {
		return playerSpawn;
	}
	public void spawnItem() {
		if (hasItem) {
		    //BasicFactory.getInstance().createItem(this.getPosition(this.playerSpawn));
		}
	}
	private void spawnDoor() {
		//BasicFactory.getInstance().createDoor(this.getPosition(new Pair<>(0,2)));
	}
	public void decreaseEnemies() {
		nEnemies--;
		System.out.println("morto un nemico. nemici rimasti: " + nEnemies);
		if (noEnemies()) {
		    spawnItem();
		    spawnDoor();
		}
	}
	public boolean noEnemies() {
		return nEnemies == 0;
	}
	
}
